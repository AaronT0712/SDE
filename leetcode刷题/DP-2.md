1. **01 背包问题**
   有一批物品 (**i**)，背包体积有限 (**j**)，如何装，使得 **价值最大**

   + 创建 **dp[i] [j]**，用以记录，i 和 j 情况下，*最大的价值*；
   + 对于一个物品：**不装** `dp[i-1][j]`，**装** `dp[i-1][j-VOLUME] + VALUE`;
   + 所以，**dp[i] [j] = MAX (装，不装)**；

2. **01背包的变式**
   如果，装入的物品，分为 *主件 & 附件*，必须 *装了主件，才能装相应的附件*，这个问题咋办

   + **跳过附件**，**对主件进行选择**
   + **不装，装主件，主件+附件1，主件+附件2，主件+附件1+附件2**；
   + 选出最大即可；
   + 需要 **时刻保持，不超过体积上限！**

3. **最长的上升序列**

   ```java
   for(int i=1; i<length; i++) {
     for(int j=0; j<i; j++) {
       if (arr[j] < arr[i]) {	// j < i: 表示增长
         dp[i] = Math.max(dp[i], dp[j]+1);		// 如果 当前子序列+1更长，则 选它
       }																			// +1 是因为 长度+1
     }
   }
   ```

4. **最长的上升变式：山型问题**

   + 找到 **最长的上升序列 dpInc[]**；
   + 找到 **最长的下降序列 dpDes[]**；
   + 对于 **index**，找到 **dpInc[index] + dpDes[index] - 1**，即为，**最长的山**；（-1 是因为有一个点 被重复算进去了）