{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n  const builder = new PieceTreeTextBufferBuilder();\n  builder.acceptChunk(text);\n  return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n  const builder = new PieceTreeTextBufferBuilder();\n  let chunk;\n  while (typeof (chunk = snapshot.read()) === 'string') {\n    builder.acceptChunk(chunk);\n  }\n  return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n  let factory;\n  if (typeof value === 'string') {\n    factory = createTextBufferFactory(value);\n  } else if (model.isITextSnapshot(value)) {\n    factory = createTextBufferFactoryFromSnapshot(value);\n  } else {\n    factory = value;\n  }\n  return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n  constructor(source) {\n    this._source = source;\n    this._eos = false;\n  }\n  read() {\n    if (this._eos) {\n      return null;\n    }\n    const result = [];\n    let resultCnt = 0;\n    let resultLength = 0;\n    do {\n      const tmp = this._source.read();\n      if (tmp === null) {\n        // end-of-stream\n        this._eos = true;\n        if (resultCnt === 0) {\n          return null;\n        } else {\n          return result.join('');\n        }\n      }\n      if (tmp.length > 0) {\n        result[resultCnt++] = tmp;\n        resultLength += tmp.length;\n      }\n      if (resultLength >= 64 * 1024) {\n        return result.join('');\n      }\n    } while (true);\n  }\n}\nconst invalidFunc = () => {\n  throw new Error(`Invalid change accessor`);\n};\nlet TextModel = class TextModel extends Disposable {\n  static resolveOptions(textBuffer, options) {\n    if (options.detectIndentation) {\n      const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n      return new model.TextModelResolvedOptions({\n        tabSize: guessedIndentation.tabSize,\n        indentSize: 'tabSize',\n        insertSpaces: guessedIndentation.insertSpaces,\n        trimAutoWhitespace: options.trimAutoWhitespace,\n        defaultEOL: options.defaultEOL,\n        bracketPairColorizationOptions: options.bracketPairColorizationOptions\n      });\n    }\n    return new model.TextModelResolvedOptions(options);\n  }\n  get onDidChangeLanguage() {\n    return this._tokenizationTextModelPart.onDidChangeLanguage;\n  }\n  get onDidChangeLanguageConfiguration() {\n    return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration;\n  }\n  get onDidChangeTokens() {\n    return this._tokenizationTextModelPart.onDidChangeTokens;\n  }\n  onDidChangeContent(listener) {\n    return this._eventEmitter.slowEvent(e => listener(e.contentChangedEvent));\n  }\n  onDidChangeContentOrInjectedText(listener) {\n    return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n  }\n  _isDisposing() {\n    return this.__isDisposing;\n  }\n  get tokenization() {\n    return this._tokenizationTextModelPart;\n  }\n  get bracketPairs() {\n    return this._bracketPairs;\n  }\n  get guides() {\n    return this._guidesTextModelPart;\n  }\n  constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {\n    super();\n    this._undoRedoService = _undoRedoService;\n    this._languageService = _languageService;\n    this._languageConfigurationService = _languageConfigurationService;\n    //#region Events\n    this._onWillDispose = this._register(new Emitter());\n    this.onWillDispose = this._onWillDispose.event;\n    this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n    this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n    this._onDidChangeOptions = this._register(new Emitter());\n    this.onDidChangeOptions = this._onDidChangeOptions.event;\n    this._onDidChangeAttached = this._register(new Emitter());\n    this.onDidChangeAttached = this._onDidChangeAttached.event;\n    this._onDidChangeInjectedText = this._register(new Emitter());\n    this._eventEmitter = this._register(new DidChangeContentEmitter());\n    this._languageSelectionListener = this._register(new MutableDisposable());\n    this._deltaDecorationCallCnt = 0;\n    this._attachedViews = new AttachedViews();\n    // Generate a new unique model id\n    MODEL_ID++;\n    this.id = '$model' + MODEL_ID;\n    this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n    if (typeof associatedResource === 'undefined' || associatedResource === null) {\n      this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n    } else {\n      this._associatedResource = associatedResource;\n    }\n    this._attachedEditorCount = 0;\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(source, creationOptions.defaultEOL);\n    this._buffer = textBuffer;\n    this._bufferDisposable = disposable;\n    this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n    const languageId = typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId;\n    if (typeof languageIdOrSelection !== 'string') {\n      this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n    }\n    this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n    this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n    this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n    this._tokenizationTextModelPart = new TokenizationTextModelPart(this._languageService, this._languageConfigurationService, this, this._bracketPairs, languageId, this._attachedViews);\n    const bufferLineCount = this._buffer.getLineCount();\n    const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n    // !!! Make a decision in the ctor and permanently respect this decision !!!\n    // If a model is too large at construction time, it will never get tokenized,\n    // under no circumstances.\n    if (creationOptions.largeFileOptimizations) {\n      this._isTooLargeForTokenization = bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD || bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD;\n    } else {\n      this._isTooLargeForTokenization = false;\n    }\n    this._isTooLargeForSyncing = bufferTextLength > TextModel._MODEL_SYNC_LIMIT;\n    this._versionId = 1;\n    this._alternativeVersionId = 1;\n    this._initialUndoRedoSnapshot = null;\n    this._isDisposed = false;\n    this.__isDisposing = false;\n    this._instanceId = strings.singleLetterHash(MODEL_ID);\n    this._lastDecorationId = 0;\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees();\n    this._commandManager = new EditStack(this, this._undoRedoService);\n    this._isUndoing = false;\n    this._isRedoing = false;\n    this._trimAutoWhitespaceLines = null;\n    this._register(this._decorationProvider.onDidChange(() => {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._onDidChangeDecorations.fire();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }));\n    this._languageService.requestRichLanguageFeatures(languageId);\n  }\n  dispose() {\n    this.__isDisposing = true;\n    this._onWillDispose.fire();\n    this._tokenizationTextModelPart.dispose();\n    this._isDisposed = true;\n    super.dispose();\n    this._bufferDisposable.dispose();\n    this.__isDisposing = false;\n    // Manually release reference to previous text buffer to avoid large leaks\n    // in case someone leaks a TextModel reference\n    const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n    emptyDisposedTextBuffer.dispose();\n    this._buffer = emptyDisposedTextBuffer;\n    this._bufferDisposable = Disposable.None;\n  }\n  _assertNotDisposed() {\n    if (this._isDisposed) {\n      throw new Error('Model is disposed!');\n    }\n  }\n  _emitContentChangedEvent(rawChange, change) {\n    if (this.__isDisposing) {\n      // Do not confuse listeners by emitting any event after disposing\n      return;\n    }\n    this._tokenizationTextModelPart.handleDidChangeContent(change);\n    this._bracketPairs.handleDidChangeContent(change);\n    this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n  }\n  setValue(value) {\n    this._assertNotDisposed();\n    if (value === null || value === undefined) {\n      throw illegalArgument();\n    }\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(value, this._options.defaultEOL);\n    this._setValueFromTextBuffer(textBuffer, disposable);\n  }\n  _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n    return {\n      changes: [{\n        range: range,\n        rangeOffset: rangeOffset,\n        rangeLength: rangeLength,\n        text: text\n      }],\n      eol: this._buffer.getEOL(),\n      isEolChange: isEolChange,\n      versionId: this.getVersionId(),\n      isUndoing: isUndoing,\n      isRedoing: isRedoing,\n      isFlush: isFlush\n    };\n  }\n  _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n    this._assertNotDisposed();\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    this._buffer = textBuffer;\n    this._bufferDisposable.dispose();\n    this._bufferDisposable = textBufferDisposable;\n    this._increaseVersionId();\n    // Destroy all my decorations\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees();\n    // Destroy my edit history and settings\n    this._commandManager.clear();\n    this._trimAutoWhitespaceLines = null;\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawFlush()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n  }\n  setEOL(eol) {\n    this._assertNotDisposed();\n    const newEOL = eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n';\n    if (this._buffer.getEOL() === newEOL) {\n      // Nothing to do\n      return;\n    }\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    this._onBeforeEOLChange();\n    this._buffer.setEOL(newEOL);\n    this._increaseVersionId();\n    this._onAfterEOLChange();\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawEOLChanged()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n  }\n  _onBeforeEOLChange() {\n    // Ensure all decorations get their `range` set.\n    this._decorationsTree.ensureAllNodesHaveRanges(this);\n  }\n  _onAfterEOLChange() {\n    // Transform back `range` to offsets\n    const versionId = this.getVersionId();\n    const allDecorations = this._decorationsTree.collectNodesPostOrder();\n    for (let i = 0, len = allDecorations.length; i < len; i++) {\n      const node = allDecorations[i];\n      const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n      const delta = node.cachedAbsoluteStart - node.start;\n      const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n      const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n      node.cachedAbsoluteStart = startOffset;\n      node.cachedAbsoluteEnd = endOffset;\n      node.cachedVersionId = versionId;\n      node.start = startOffset - delta;\n      node.end = endOffset - delta;\n      recomputeMaxEnd(node);\n    }\n  }\n  onBeforeAttached() {\n    this._attachedEditorCount++;\n    if (this._attachedEditorCount === 1) {\n      this._tokenizationTextModelPart.handleDidChangeAttached();\n      this._onDidChangeAttached.fire(undefined);\n    }\n    return this._attachedViews.attachView();\n  }\n  onBeforeDetached(view) {\n    this._attachedEditorCount--;\n    if (this._attachedEditorCount === 0) {\n      this._tokenizationTextModelPart.handleDidChangeAttached();\n      this._onDidChangeAttached.fire(undefined);\n    }\n    this._attachedViews.detachView(view);\n  }\n  isAttachedToEditor() {\n    return this._attachedEditorCount > 0;\n  }\n  getAttachedEditorCount() {\n    return this._attachedEditorCount;\n  }\n  isTooLargeForSyncing() {\n    return this._isTooLargeForSyncing;\n  }\n  isTooLargeForTokenization() {\n    return this._isTooLargeForTokenization;\n  }\n  isDisposed() {\n    return this._isDisposed;\n  }\n  isDominatedByLongLines() {\n    this._assertNotDisposed();\n    if (this.isTooLargeForTokenization()) {\n      // Cannot word wrap huge files anyways, so it doesn't really matter\n      return false;\n    }\n    let smallLineCharCount = 0;\n    let longLineCharCount = 0;\n    const lineCount = this._buffer.getLineCount();\n    for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n      const lineLength = this._buffer.getLineLength(lineNumber);\n      if (lineLength >= LONG_LINE_BOUNDARY) {\n        longLineCharCount += lineLength;\n      } else {\n        smallLineCharCount += lineLength;\n      }\n    }\n    return longLineCharCount > smallLineCharCount;\n  }\n  get uri() {\n    return this._associatedResource;\n  }\n  //#region Options\n  getOptions() {\n    this._assertNotDisposed();\n    return this._options;\n  }\n  getFormattingOptions() {\n    return {\n      tabSize: this._options.indentSize,\n      insertSpaces: this._options.insertSpaces\n    };\n  }\n  updateOptions(_newOpts) {\n    this._assertNotDisposed();\n    const tabSize = typeof _newOpts.tabSize !== 'undefined' ? _newOpts.tabSize : this._options.tabSize;\n    const indentSize = typeof _newOpts.indentSize !== 'undefined' ? _newOpts.indentSize : this._options.originalIndentSize;\n    const insertSpaces = typeof _newOpts.insertSpaces !== 'undefined' ? _newOpts.insertSpaces : this._options.insertSpaces;\n    const trimAutoWhitespace = typeof _newOpts.trimAutoWhitespace !== 'undefined' ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n    const bracketPairColorizationOptions = typeof _newOpts.bracketColorizationOptions !== 'undefined' ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n    const newOpts = new model.TextModelResolvedOptions({\n      tabSize: tabSize,\n      indentSize: indentSize,\n      insertSpaces: insertSpaces,\n      defaultEOL: this._options.defaultEOL,\n      trimAutoWhitespace: trimAutoWhitespace,\n      bracketPairColorizationOptions\n    });\n    if (this._options.equals(newOpts)) {\n      return;\n    }\n    const e = this._options.createChangeEvent(newOpts);\n    this._options = newOpts;\n    this._bracketPairs.handleDidChangeOptions(e);\n    this._decorationProvider.handleDidChangeOptions(e);\n    this._onDidChangeOptions.fire(e);\n  }\n  detectIndentation(defaultInsertSpaces, defaultTabSize) {\n    this._assertNotDisposed();\n    const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n    this.updateOptions({\n      insertSpaces: guessedIndentation.insertSpaces,\n      tabSize: guessedIndentation.tabSize,\n      indentSize: guessedIndentation.tabSize // TODO@Alex: guess indentSize independent of tabSize\n    });\n  }\n\n  normalizeIndentation(str) {\n    this._assertNotDisposed();\n    return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n  }\n  //#endregion\n  //#region Reading\n  getVersionId() {\n    this._assertNotDisposed();\n    return this._versionId;\n  }\n  mightContainRTL() {\n    return this._buffer.mightContainRTL();\n  }\n  mightContainUnusualLineTerminators() {\n    return this._buffer.mightContainUnusualLineTerminators();\n  }\n  removeUnusualLineTerminators(selections = null) {\n    const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n    this._buffer.resetMightContainUnusualLineTerminators();\n    this.pushEditOperations(selections, matches.map(m => ({\n      range: m.range,\n      text: null\n    })), () => null);\n  }\n  mightContainNonBasicASCII() {\n    return this._buffer.mightContainNonBasicASCII();\n  }\n  getAlternativeVersionId() {\n    this._assertNotDisposed();\n    return this._alternativeVersionId;\n  }\n  getInitialUndoRedoSnapshot() {\n    this._assertNotDisposed();\n    return this._initialUndoRedoSnapshot;\n  }\n  getOffsetAt(rawPosition) {\n    this._assertNotDisposed();\n    const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n    return this._buffer.getOffsetAt(position.lineNumber, position.column);\n  }\n  getPositionAt(rawOffset) {\n    this._assertNotDisposed();\n    const offset = Math.min(this._buffer.getLength(), Math.max(0, rawOffset));\n    return this._buffer.getPositionAt(offset);\n  }\n  _increaseVersionId() {\n    this._versionId = this._versionId + 1;\n    this._alternativeVersionId = this._versionId;\n  }\n  _overwriteVersionId(versionId) {\n    this._versionId = versionId;\n  }\n  _overwriteAlternativeVersionId(newAlternativeVersionId) {\n    this._alternativeVersionId = newAlternativeVersionId;\n  }\n  _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n    this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n  }\n  getValue(eol, preserveBOM = false) {\n    this._assertNotDisposed();\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueInRange(fullModelRange, eol);\n    if (preserveBOM) {\n      return this._buffer.getBOM() + fullModelValue;\n    }\n    return fullModelValue;\n  }\n  createSnapshot(preserveBOM = false) {\n    return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n  }\n  getValueLength(eol, preserveBOM = false) {\n    this._assertNotDisposed();\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n    if (preserveBOM) {\n      return this._buffer.getBOM().length + fullModelValue;\n    }\n    return fullModelValue;\n  }\n  getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n    this._assertNotDisposed();\n    return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n  }\n  getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n    this._assertNotDisposed();\n    return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n  }\n  getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n    this._assertNotDisposed();\n    return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n  }\n  getLineCount() {\n    this._assertNotDisposed();\n    return this._buffer.getLineCount();\n  }\n  getLineContent(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineContent(lineNumber);\n  }\n  getLineLength(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLength(lineNumber);\n  }\n  getLinesContent() {\n    this._assertNotDisposed();\n    return this._buffer.getLinesContent();\n  }\n  getEOL() {\n    this._assertNotDisposed();\n    return this._buffer.getEOL();\n  }\n  getEndOfLineSequence() {\n    this._assertNotDisposed();\n    return this._buffer.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */;\n  }\n\n  getLineMinColumn(lineNumber) {\n    this._assertNotDisposed();\n    return 1;\n  }\n  getLineMaxColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLength(lineNumber) + 1;\n  }\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n  }\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n  }\n  /**\n   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n   * Will try to not allocate if possible.\n   */\n  _validateRangeRelaxedNoAllocations(range) {\n    const linesCount = this._buffer.getLineCount();\n    const initialStartLineNumber = range.startLineNumber;\n    const initialStartColumn = range.startColumn;\n    let startLineNumber = Math.floor(typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber) ? initialStartLineNumber : 1);\n    let startColumn = Math.floor(typeof initialStartColumn === 'number' && !isNaN(initialStartColumn) ? initialStartColumn : 1);\n    if (startLineNumber < 1) {\n      startLineNumber = 1;\n      startColumn = 1;\n    } else if (startLineNumber > linesCount) {\n      startLineNumber = linesCount;\n      startColumn = this.getLineMaxColumn(startLineNumber);\n    } else {\n      if (startColumn <= 1) {\n        startColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(startLineNumber);\n        if (startColumn >= maxColumn) {\n          startColumn = maxColumn;\n        }\n      }\n    }\n    const initialEndLineNumber = range.endLineNumber;\n    const initialEndColumn = range.endColumn;\n    let endLineNumber = Math.floor(typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber) ? initialEndLineNumber : 1);\n    let endColumn = Math.floor(typeof initialEndColumn === 'number' && !isNaN(initialEndColumn) ? initialEndColumn : 1);\n    if (endLineNumber < 1) {\n      endLineNumber = 1;\n      endColumn = 1;\n    } else if (endLineNumber > linesCount) {\n      endLineNumber = linesCount;\n      endColumn = this.getLineMaxColumn(endLineNumber);\n    } else {\n      if (endColumn <= 1) {\n        endColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(endLineNumber);\n        if (endColumn >= maxColumn) {\n          endColumn = maxColumn;\n        }\n      }\n    }\n    if (initialStartLineNumber === startLineNumber && initialStartColumn === startColumn && initialEndLineNumber === endLineNumber && initialEndColumn === endColumn && range instanceof Range && !(range instanceof Selection)) {\n      return range;\n    }\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  _isValidPosition(lineNumber, column, validationType) {\n    if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n      return false;\n    }\n    if (isNaN(lineNumber) || isNaN(column)) {\n      return false;\n    }\n    if (lineNumber < 1 || column < 1) {\n      return false;\n    }\n    if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n      return false;\n    }\n    const lineCount = this._buffer.getLineCount();\n    if (lineNumber > lineCount) {\n      return false;\n    }\n    if (column === 1) {\n      return true;\n    }\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n    if (column > maxColumn) {\n      return false;\n    }\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _validatePosition(_lineNumber, _column, validationType) {\n    const lineNumber = Math.floor(typeof _lineNumber === 'number' && !isNaN(_lineNumber) ? _lineNumber : 1);\n    const column = Math.floor(typeof _column === 'number' && !isNaN(_column) ? _column : 1);\n    const lineCount = this._buffer.getLineCount();\n    if (lineNumber < 1) {\n      return new Position(1, 1);\n    }\n    if (lineNumber > lineCount) {\n      return new Position(lineCount, this.getLineMaxColumn(lineCount));\n    }\n    if (column <= 1) {\n      return new Position(lineNumber, 1);\n    }\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n    if (column >= maxColumn) {\n      return new Position(lineNumber, maxColumn);\n    }\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      // If the position would end up in the middle of a high-low surrogate pair,\n      // we move it to before the pair\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return new Position(lineNumber, column - 1);\n      }\n    }\n    return new Position(lineNumber, column);\n  }\n  validatePosition(position) {\n    const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n    this._assertNotDisposed();\n    // Avoid object allocation and cover most likely case\n    if (position instanceof Position) {\n      if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n        return position;\n      }\n    }\n    return this._validatePosition(position.lineNumber, position.column, validationType);\n  }\n  _isValidRange(range, validationType) {\n    const startLineNumber = range.startLineNumber;\n    const startColumn = range.startColumn;\n    const endLineNumber = range.endLineNumber;\n    const endColumn = range.endColumn;\n    if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n      return false;\n    }\n    if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n      return false;\n    }\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return true;\n      }\n      return false;\n    }\n    return true;\n  }\n  validateRange(_range) {\n    const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n    this._assertNotDisposed();\n    // Avoid object allocation and cover most likely case\n    if (_range instanceof Range && !(_range instanceof Selection)) {\n      if (this._isValidRange(_range, validationType)) {\n        return _range;\n      }\n    }\n    const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n    const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n    const startLineNumber = start.lineNumber;\n    const startColumn = start.column;\n    const endLineNumber = end.lineNumber;\n    const endColumn = end.column;\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      }\n      if (startLineNumber === endLineNumber && startColumn === endColumn) {\n        // do not expand a collapsed range, simply move it to a valid location\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n      }\n      if (startInsideSurrogatePair && endInsideSurrogatePair) {\n        // expand range at both ends\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n      }\n      if (startInsideSurrogatePair) {\n        // only expand range at the start\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n      }\n      // only expand range at the end\n      return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n    }\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  modifyPosition(rawPosition, offset) {\n    this._assertNotDisposed();\n    const candidate = this.getOffsetAt(rawPosition) + offset;\n    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n  }\n  getFullModelRange() {\n    this._assertNotDisposed();\n    const lineCount = this.getLineCount();\n    return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n  }\n  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n    return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  }\n  findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n    this._assertNotDisposed();\n    let searchRanges = null;\n    if (rawSearchScope !== null) {\n      if (!Array.isArray(rawSearchScope)) {\n        rawSearchScope = [rawSearchScope];\n      }\n      if (rawSearchScope.every(searchScope => Range.isIRange(searchScope))) {\n        searchRanges = rawSearchScope.map(searchScope => this.validateRange(searchScope));\n      }\n    }\n    if (searchRanges === null) {\n      searchRanges = [this.getFullModelRange()];\n    }\n    searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n    const uniqueSearchRanges = [];\n    uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n      if (Range.areIntersecting(prev, curr)) {\n        return prev.plusRange(curr);\n      }\n      uniqueSearchRanges.push(prev);\n      return curr;\n    }));\n    let matchMapper;\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      // not regex, not multi line\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n      if (!searchData) {\n        return [];\n      }\n      matchMapper = searchRange => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    } else {\n      matchMapper = searchRange => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n    }\n    return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n  }\n  findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n    const searchStart = this.validatePosition(rawSearchStart);\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n      if (!searchData) {\n        return null;\n      }\n      const lineCount = this.getLineCount();\n      let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n      let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n      TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n      if (ret.length > 0) {\n        return ret[0];\n      }\n      searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n      ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n      if (ret.length > 0) {\n        return ret[0];\n      }\n      return null;\n    }\n    return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  }\n  findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n    const searchStart = this.validatePosition(rawSearchStart);\n    return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  }\n  //#endregion\n  //#region Editing\n  pushStackElement() {\n    this._commandManager.pushStackElement();\n  }\n  popStackElement() {\n    this._commandManager.popStackElement();\n  }\n  pushEOL(eol) {\n    const currentEOL = this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */;\n    if (currentEOL === eol) {\n      return;\n    }\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      if (this._initialUndoRedoSnapshot === null) {\n        this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n      }\n      this._commandManager.pushEOL(eol);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _validateEditOperation(rawOperation) {\n    if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n      return rawOperation;\n    }\n    return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n  }\n  _validateEditOperations(rawOperations) {\n    const result = [];\n    for (let i = 0, len = rawOperations.length; i < len; i++) {\n      result[i] = this._validateEditOperation(rawOperations[i]);\n    }\n    return result;\n  }\n  pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n      // Go through each saved line number and insert a trim whitespace edit\n      // if it is safe to do so (no conflicts with other edits).\n      const incomingEdits = editOperations.map(op => {\n        return {\n          range: this.validateRange(op.range),\n          text: op.text\n        };\n      });\n      // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n      // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n      let editsAreNearCursors = true;\n      if (beforeCursorState) {\n        for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n          const sel = beforeCursorState[i];\n          let foundEditNearSel = false;\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            const editRange = incomingEdits[j].range;\n            const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n            const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n            if (!selIsAbove && !selIsBelow) {\n              foundEditNearSel = true;\n              break;\n            }\n          }\n          if (!foundEditNearSel) {\n            editsAreNearCursors = false;\n            break;\n          }\n        }\n      }\n      if (editsAreNearCursors) {\n        for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n          const trimLineNumber = this._trimAutoWhitespaceLines[i];\n          const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n          let allowTrimLine = true;\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            const editRange = incomingEdits[j].range;\n            const editText = incomingEdits[j].text;\n            if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n              // `trimLine` is completely outside this edit\n              continue;\n            }\n            // At this point:\n            //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n              // This edit inserts a new line (and maybe other text) after `trimLine`\n              continue;\n            }\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1 && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n              // This edit inserts a new line (and maybe other text) before `trimLine`\n              continue;\n            }\n            // Looks like we can't trim this line as it would interfere with an incoming edit\n            allowTrimLine = false;\n            break;\n          }\n          if (allowTrimLine) {\n            const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n            editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n          }\n        }\n      }\n      this._trimAutoWhitespaceLines = null;\n    }\n    if (this._initialUndoRedoSnapshot === null) {\n      this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n    }\n    return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n  }\n  _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.newPosition);\n      const rangeEnd = this.getPositionAt(change.newEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.oldText\n      };\n    });\n    this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n  }\n  _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.oldPosition);\n      const rangeEnd = this.getPositionAt(change.oldEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.newText\n      };\n    });\n    this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n  }\n  _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      this._isUndoing = isUndoing;\n      this._isRedoing = isRedoing;\n      this.applyEdits(edits, false);\n      this.setEOL(eol);\n      this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n    } finally {\n      this._isUndoing = false;\n      this._isRedoing = false;\n      this._eventEmitter.endDeferredEmit(resultingSelection);\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  applyEdits(rawOperations, computeUndoEdits = false) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      const operations = this._validateEditOperations(rawOperations);\n      return this._doApplyEdits(operations, computeUndoEdits);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _doApplyEdits(rawOperations, computeUndoEdits) {\n    const oldLineCount = this._buffer.getLineCount();\n    const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n    const newLineCount = this._buffer.getLineCount();\n    const contentChanges = result.changes;\n    this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n    if (contentChanges.length !== 0) {\n      // We do a first pass to update decorations\n      // because we want to read decorations in the second pass\n      // where we will emit content change events\n      // and we want to read the final decorations\n      for (let i = 0, len = contentChanges.length; i < len; i++) {\n        const change = contentChanges[i];\n        this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n      }\n      const rawContentChanges = [];\n      this._increaseVersionId();\n      let lineCount = oldLineCount;\n      for (let i = 0, len = contentChanges.length; i < len; i++) {\n        const change = contentChanges[i];\n        const [eolCount] = countEOL(change.text);\n        this._onDidChangeDecorations.fire();\n        const startLineNumber = change.range.startLineNumber;\n        const endLineNumber = change.range.endLineNumber;\n        const deletingLinesCnt = endLineNumber - startLineNumber;\n        const insertingLinesCnt = eolCount;\n        const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n        const changeLineCountDelta = insertingLinesCnt - deletingLinesCnt;\n        const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n        const firstEditLineNumber = currentEditStartLineNumber;\n        const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n        const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n        const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n        const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n        for (let j = editingLinesCnt; j >= 0; j--) {\n          const editLineNumber = startLineNumber + j;\n          const currentEditLineNumber = currentEditStartLineNumber + j;\n          injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n          const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n          rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n        }\n        if (editingLinesCnt < deletingLinesCnt) {\n          // Must delete some lines\n          const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n          rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n        }\n        if (editingLinesCnt < insertingLinesCnt) {\n          const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n          // Must insert some lines\n          const spliceLineNumber = startLineNumber + editingLinesCnt;\n          const cnt = insertingLinesCnt - editingLinesCnt;\n          const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n          const injectedTexts = [];\n          const newLines = [];\n          for (let i = 0; i < cnt; i++) {\n            const lineNumber = fromLineNumber + i;\n            newLines[i] = this.getLineContent(lineNumber);\n            injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n            injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n          }\n          rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n        }\n        lineCount += changeLineCountDelta;\n      }\n      this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n        changes: contentChanges,\n        eol: this._buffer.getEOL(),\n        isEolChange: false,\n        versionId: this.getVersionId(),\n        isUndoing: this._isUndoing,\n        isRedoing: this._isRedoing,\n        isFlush: false\n      });\n    }\n    return result.reverseEdits === null ? undefined : result.reverseEdits;\n  }\n  undo() {\n    return this._undoRedoService.undo(this.uri);\n  }\n  canUndo() {\n    return this._undoRedoService.canUndo(this.uri);\n  }\n  redo() {\n    return this._undoRedoService.redo(this.uri);\n  }\n  canRedo() {\n    return this._undoRedoService.canRedo(this.uri);\n  }\n  //#endregion\n  //#region Decorations\n  handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n    // This is called before the decoration changed event is fired.\n    if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n      return;\n    }\n    const affectedLines = Array.from(affectedInjectedTextLines);\n    const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n    this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n  }\n  changeDecorations(callback, ownerId = 0) {\n    this._assertNotDisposed();\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      return this._changeDecorations(ownerId, callback);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _changeDecorations(ownerId, callback) {\n    const changeAccessor = {\n      addDecoration: (range, options) => {\n        return this._deltaDecorationsImpl(ownerId, [], [{\n          range: range,\n          options: options\n        }])[0];\n      },\n      changeDecoration: (id, newRange) => {\n        this._changeDecorationImpl(id, newRange);\n      },\n      changeDecorationOptions: (id, options) => {\n        this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n      },\n      removeDecoration: id => {\n        this._deltaDecorationsImpl(ownerId, [id], []);\n      },\n      deltaDecorations: (oldDecorations, newDecorations) => {\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n          // nothing to do\n          return [];\n        }\n        return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n      }\n    };\n    let result = null;\n    try {\n      result = callback(changeAccessor);\n    } catch (e) {\n      onUnexpectedError(e);\n    }\n    // Invalidate change accessor\n    changeAccessor.addDecoration = invalidFunc;\n    changeAccessor.changeDecoration = invalidFunc;\n    changeAccessor.changeDecorationOptions = invalidFunc;\n    changeAccessor.removeDecoration = invalidFunc;\n    changeAccessor.deltaDecorations = invalidFunc;\n    return result;\n  }\n  deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n    this._assertNotDisposed();\n    if (!oldDecorations) {\n      oldDecorations = [];\n    }\n    if (oldDecorations.length === 0 && newDecorations.length === 0) {\n      // nothing to do\n      return [];\n    }\n    try {\n      this._deltaDecorationCallCnt++;\n      if (this._deltaDecorationCallCnt > 1) {\n        console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n        onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n      }\n      this._onDidChangeDecorations.beginDeferredEmit();\n      return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n      this._deltaDecorationCallCnt--;\n    }\n  }\n  _getTrackedRange(id) {\n    return this.getDecorationRange(id);\n  }\n  _setTrackedRange(id, newRange, newStickiness) {\n    const node = id ? this._decorations[id] : null;\n    if (!node) {\n      if (!newRange) {\n        // node doesn't exist, the request is to delete => nothing to do\n        return null;\n      }\n      // node doesn't exist, the request is to set => add the tracked range\n      return this._deltaDecorationsImpl(0, [], [{\n        range: newRange,\n        options: TRACKED_RANGE_OPTIONS[newStickiness]\n      }], true)[0];\n    }\n    if (!newRange) {\n      // node exists, the request is to delete => delete node\n      this._decorationsTree.delete(node);\n      delete this._decorations[node.id];\n      return null;\n    }\n    // node exists, the request is to set => change the tracked range and its options\n    const range = this._validateRangeRelaxedNoAllocations(newRange);\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n    this._decorationsTree.delete(node);\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n    node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n    this._decorationsTree.insert(node);\n    return node.id;\n  }\n  removeAllDecorationsWithOwnerId(ownerId) {\n    if (this._isDisposed) {\n      return;\n    }\n    const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n    for (let i = 0, len = nodes.length; i < len; i++) {\n      const node = nodes[i];\n      this._decorationsTree.delete(node);\n      delete this._decorations[node.id];\n    }\n  }\n  getDecorationOptions(decorationId) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return null;\n    }\n    return node.options;\n  }\n  getDecorationRange(decorationId) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return null;\n    }\n    return this._decorationsTree.getNodeRange(this, node);\n  }\n  getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      return [];\n    }\n    return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n  }\n  getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n    const lineCount = this.getLineCount();\n    const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n    const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n    const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n    pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n    return decorations;\n  }\n  getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n    const validatedRange = this.validateRange(range);\n    const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n    pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n    return decorations;\n  }\n  getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n    return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n  }\n  getInjectedTextDecorations(ownerId = 0) {\n    return this._decorationsTree.getAllInjectedText(this, ownerId);\n  }\n  _getInjectedTextInLine(lineNumber) {\n    const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n    const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n    const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n    return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n  }\n  getAllDecorations(ownerId = 0, filterOutValidation = false) {\n    let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n    result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n    return result;\n  }\n  getAllMarginDecorations(ownerId = 0) {\n    return this._decorationsTree.getAll(this, ownerId, false, false, true);\n  }\n  _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n    const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n    const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n    return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n  }\n  getRangeAt(start, end) {\n    return this._buffer.getRangeAt(start, end - start);\n  }\n  _changeDecorationImpl(decorationId, _range) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return;\n    }\n    if (node.options.after) {\n      const oldRange = this.getDecorationRange(decorationId);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n    }\n    if (node.options.before) {\n      const oldRange = this.getDecorationRange(decorationId);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n    }\n    const range = this._validateRangeRelaxedNoAllocations(_range);\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n    this._decorationsTree.delete(node);\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n    this._decorationsTree.insert(node);\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n    if (node.options.after) {\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n    }\n    if (node.options.before) {\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n    }\n  }\n  _changeDecorationOptionsImpl(decorationId, options) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return;\n    }\n    const nodeWasInOverviewRuler = node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n    const nodeIsInOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n    this._onDidChangeDecorations.checkAffectedAndFire(options);\n    if (node.options.after || options.after) {\n      const nodeRange = this._decorationsTree.getNodeRange(this, node);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n    }\n    if (node.options.before || options.before) {\n      const nodeRange = this._decorationsTree.getNodeRange(this, node);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n    }\n    if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n      // Delete + Insert due to an overview ruler status change\n      this._decorationsTree.delete(node);\n      node.setOptions(options);\n      this._decorationsTree.insert(node);\n    } else {\n      node.setOptions(options);\n    }\n  }\n  _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n    const versionId = this.getVersionId();\n    const oldDecorationsLen = oldDecorationsIds.length;\n    let oldDecorationIndex = 0;\n    const newDecorationsLen = newDecorations.length;\n    let newDecorationIndex = 0;\n    this._onDidChangeDecorations.beginDeferredEmit();\n    try {\n      const result = new Array(newDecorationsLen);\n      while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n        let node = null;\n        if (oldDecorationIndex < oldDecorationsLen) {\n          // (1) get ourselves an old node\n          do {\n            node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n          } while (!node && oldDecorationIndex < oldDecorationsLen);\n          // (2) remove the node from the tree (if it exists)\n          if (node) {\n            if (node.options.after) {\n              const nodeRange = this._decorationsTree.getNodeRange(this, node);\n              this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n            }\n            if (node.options.before) {\n              const nodeRange = this._decorationsTree.getNodeRange(this, node);\n              this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n            }\n            this._decorationsTree.delete(node);\n            if (!suppressEvents) {\n              this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n            }\n          }\n        }\n        if (newDecorationIndex < newDecorationsLen) {\n          // (3) create a new node if necessary\n          if (!node) {\n            const internalDecorationId = ++this._lastDecorationId;\n            const decorationId = `${this._instanceId};${internalDecorationId}`;\n            node = new IntervalNode(decorationId, 0, 0);\n            this._decorations[decorationId] = node;\n          }\n          // (4) initialize node\n          const newDecoration = newDecorations[newDecorationIndex];\n          const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n          const options = _normalizeOptions(newDecoration.options);\n          const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n          const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n          node.ownerId = ownerId;\n          node.reset(versionId, startOffset, endOffset, range);\n          node.setOptions(options);\n          if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n          }\n          if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n          }\n          if (!suppressEvents) {\n            this._onDidChangeDecorations.checkAffectedAndFire(options);\n          }\n          this._decorationsTree.insert(node);\n          result[newDecorationIndex] = node.id;\n          newDecorationIndex++;\n        } else {\n          if (node) {\n            delete this._decorations[node.id];\n          }\n        }\n      }\n      return result;\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  //#endregion\n  //#region Tokenization\n  // TODO move them to the tokenization part.\n  getLanguageId() {\n    return this.tokenization.getLanguageId();\n  }\n  setLanguage(languageIdOrSelection, source) {\n    if (typeof languageIdOrSelection === 'string') {\n      this._languageSelectionListener.clear();\n      this._setLanguage(languageIdOrSelection, source);\n    } else {\n      this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n      this._setLanguage(languageIdOrSelection.languageId, source);\n    }\n  }\n  _setLanguage(languageId, source) {\n    this.tokenization.setLanguageId(languageId, source);\n    this._languageService.requestRichLanguageFeatures(languageId);\n  }\n  getLanguageIdAtPosition(lineNumber, column) {\n    return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n  }\n  getWordAtPosition(position) {\n    return this._tokenizationTextModelPart.getWordAtPosition(position);\n  }\n  getWordUntilPosition(position) {\n    return this._tokenizationTextModelPart.getWordUntilPosition(position);\n  }\n  //#endregion\n  normalizePosition(position, affinity) {\n    return position;\n  }\n  /**\n   * Gets the column at which indentation stops at a given line.\n   * @internal\n  */\n  getLineIndentColumn(lineNumber) {\n    // Columns start with 1.\n    return indentOfLine(this.getLineContent(lineNumber)) + 1;\n  }\n};\nTextModel._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB,  // used in tests\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.DEFAULT_CREATION_OPTIONS = {\n  isForSimpleWidget: false,\n  tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n  indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n  insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n  detectIndentation: false,\n  defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n  trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n  largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n  bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions\n};\nTextModel = __decorate([__param(4, IUndoRedoService), __param(5, ILanguageService), __param(6, ILanguageConfigurationService)], TextModel);\nexport { TextModel };\nfunction indentOfLine(line) {\n  let indent = 0;\n  for (const c of line) {\n    if (c === ' ' || c === '\\t') {\n      indent++;\n    } else {\n      break;\n    }\n  }\n  return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n  return node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n}\nfunction isNodeInjectedText(node) {\n  return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n  constructor() {\n    this._decorationsTree0 = new IntervalTree();\n    this._decorationsTree1 = new IntervalTree();\n    this._injectedTextDecorationsTree = new IntervalTree();\n  }\n  ensureAllNodesHaveRanges(host) {\n    this.getAll(host, 0, false, false, false);\n  }\n  _ensureNodesHaveRanges(host, nodes) {\n    for (const node of nodes) {\n      if (node.range === null) {\n        node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n      }\n    }\n    return nodes;\n  }\n  getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n    const versionId = host.getVersionId();\n    const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n    return this._ensureNodesHaveRanges(host, result);\n  }\n  _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    return r0.concat(r1).concat(r2);\n  }\n  getInjectedTextInInterval(host, start, end, filterOwnerId) {\n    const versionId = host.getVersionId();\n    const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n    return this._ensureNodesHaveRanges(host, result).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());\n  }\n  getAllInjectedText(host, filterOwnerId) {\n    const versionId = host.getVersionId();\n    const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n    return this._ensureNodesHaveRanges(host, result).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());\n  }\n  getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n    const versionId = host.getVersionId();\n    const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n    return this._ensureNodesHaveRanges(host, result);\n  }\n  _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n    if (overviewRulerOnly) {\n      return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    } else {\n      const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n      const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n      const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n      return r0.concat(r1).concat(r2);\n    }\n  }\n  collectNodesFromOwner(ownerId) {\n    const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n    const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n    const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n    return r0.concat(r1).concat(r2);\n  }\n  collectNodesPostOrder() {\n    const r0 = this._decorationsTree0.collectNodesPostOrder();\n    const r1 = this._decorationsTree1.collectNodesPostOrder();\n    const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n    return r0.concat(r1).concat(r2);\n  }\n  insert(node) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.insert(node);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.insert(node);\n    } else {\n      this._decorationsTree0.insert(node);\n    }\n  }\n  delete(node) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.delete(node);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.delete(node);\n    } else {\n      this._decorationsTree0.delete(node);\n    }\n  }\n  getNodeRange(host, node) {\n    const versionId = host.getVersionId();\n    if (node.cachedVersionId !== versionId) {\n      this._resolveNode(node, versionId);\n    }\n    if (node.range === null) {\n      node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n    }\n    return node.range;\n  }\n  _resolveNode(node, cachedVersionId) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.resolveNode(node, cachedVersionId);\n    } else {\n      this._decorationsTree0.resolveNode(node, cachedVersionId);\n    }\n  }\n  acceptReplace(offset, length, textLength, forceMoveMarkers) {\n    this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n  }\n}\nfunction cleanClassName(className) {\n  return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n  constructor(options) {\n    this.color = options.color || '';\n    this.darkColor = options.darkColor || '';\n  }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n  constructor(options) {\n    super(options);\n    this._resolvedColor = null;\n    this.position = typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center;\n  }\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n    return this._resolvedColor;\n  }\n  invalidateCachedColor() {\n    this._resolvedColor = null;\n  }\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return color;\n    }\n    const c = color ? theme.getColor(color.id) : null;\n    if (!c) {\n      return '';\n    }\n    return c.toString();\n  }\n}\nexport class ModelDecorationGlyphMarginOptions {\n  constructor(options) {\n    var _a;\n    this.position = (_a = options === null || options === void 0 ? void 0 : options.position) !== null && _a !== void 0 ? _a : model.GlyphMarginLane.Left;\n  }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n  constructor(options) {\n    super(options);\n    this.position = options.position;\n  }\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n    return this._resolvedColor;\n  }\n  invalidateCachedColor() {\n    this._resolvedColor = undefined;\n  }\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return Color.fromHex(color);\n    }\n    return theme.getColor(color.id);\n  }\n}\nexport class ModelDecorationInjectedTextOptions {\n  static from(options) {\n    if (options instanceof ModelDecorationInjectedTextOptions) {\n      return options;\n    }\n    return new ModelDecorationInjectedTextOptions(options);\n  }\n  constructor(options) {\n    this.content = options.content || '';\n    this.inlineClassName = options.inlineClassName || null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.attachedData = options.attachedData || null;\n    this.cursorStops = options.cursorStops || null;\n  }\n}\nexport class ModelDecorationOptions {\n  static register(options) {\n    return new ModelDecorationOptions(options);\n  }\n  static createDynamic(options) {\n    return new ModelDecorationOptions(options);\n  }\n  constructor(options) {\n    var _a, _b, _c, _d, _e, _f;\n    this.description = options.description;\n    this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n    this.blockDoesNotCollapse = (_a = options.blockDoesNotCollapse) !== null && _a !== void 0 ? _a : null;\n    this.blockIsAfterEnd = (_b = options.blockIsAfterEnd) !== null && _b !== void 0 ? _b : null;\n    this.blockPadding = (_c = options.blockPadding) !== null && _c !== void 0 ? _c : null;\n    this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n    this.zIndex = options.zIndex || 0;\n    this.className = options.className ? cleanClassName(options.className) : null;\n    this.shouldFillLineOnLineBreak = (_d = options.shouldFillLineOnLineBreak) !== null && _d !== void 0 ? _d : null;\n    this.hoverMessage = options.hoverMessage || null;\n    this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n    this.isWholeLine = options.isWholeLine || false;\n    this.showIfCollapsed = options.showIfCollapsed || false;\n    this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n    this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n    this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n    this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n    this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n    this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n    this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n    this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n    this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n    this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n    this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n    this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n    this.hideInCommentTokens = (_e = options.hideInCommentTokens) !== null && _e !== void 0 ? _e : false;\n    this.hideInStringTokens = (_f = options.hideInStringTokens) !== null && _f !== void 0 ? _f : false;\n  }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({\n  description: 'empty'\n});\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [ModelDecorationOptions.register({\n  description: 'tracked-range-always-grows-when-typing-at-edges',\n  stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-never-grows-when-typing-at-edges',\n  stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-grows-only-when-typing-before',\n  stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-grows-only-when-typing-after',\n  stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */\n})];\n\nfunction _normalizeOptions(options) {\n  if (options instanceof ModelDecorationOptions) {\n    return options;\n  }\n  return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n  constructor(handleBeforeFire) {\n    super();\n    this.handleBeforeFire = handleBeforeFire;\n    this._actual = this._register(new Emitter());\n    this.event = this._actual.event;\n    this._affectedInjectedTextLines = null;\n    this._deferredCnt = 0;\n    this._shouldFireDeferred = false;\n    this._affectsMinimap = false;\n    this._affectsOverviewRuler = false;\n    this._affectsGlyphMargin = false;\n  }\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n  endDeferredEmit() {\n    var _a;\n    this._deferredCnt--;\n    if (this._deferredCnt === 0) {\n      if (this._shouldFireDeferred) {\n        this.doFire();\n      }\n      (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n      this._affectedInjectedTextLines = null;\n    }\n  }\n  recordLineAffectedByInjectedText(lineNumber) {\n    if (!this._affectedInjectedTextLines) {\n      this._affectedInjectedTextLines = new Set();\n    }\n    this._affectedInjectedTextLines.add(lineNumber);\n  }\n  checkAffectedAndFire(options) {\n    if (!this._affectsMinimap) {\n      this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n    }\n    if (!this._affectsOverviewRuler) {\n      this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n    }\n    if (!this._affectsGlyphMargin) {\n      this._affectsGlyphMargin = options.glyphMarginClassName ? true : false;\n    }\n    this.tryFire();\n  }\n  fire() {\n    this._affectsMinimap = true;\n    this._affectsOverviewRuler = true;\n    this._affectsGlyphMargin = true;\n    this.tryFire();\n  }\n  tryFire() {\n    if (this._deferredCnt === 0) {\n      this.doFire();\n    } else {\n      this._shouldFireDeferred = true;\n    }\n  }\n  doFire() {\n    this.handleBeforeFire(this._affectedInjectedTextLines);\n    const event = {\n      affectsMinimap: this._affectsMinimap,\n      affectsOverviewRuler: this._affectsOverviewRuler,\n      affectsGlyphMargin: this._affectsGlyphMargin\n    };\n    this._shouldFireDeferred = false;\n    this._affectsMinimap = false;\n    this._affectsOverviewRuler = false;\n    this._affectsGlyphMargin = false;\n    this._actual.fire(event);\n  }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n  constructor() {\n    super();\n    /**\n     * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n     */\n    this._fastEmitter = this._register(new Emitter());\n    this.fastEvent = this._fastEmitter.event;\n    this._slowEmitter = this._register(new Emitter());\n    this.slowEvent = this._slowEmitter.event;\n    this._deferredCnt = 0;\n    this._deferredEvent = null;\n  }\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n  endDeferredEmit(resultingSelection = null) {\n    this._deferredCnt--;\n    if (this._deferredCnt === 0) {\n      if (this._deferredEvent !== null) {\n        this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n        const e = this._deferredEvent;\n        this._deferredEvent = null;\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n      }\n    }\n  }\n  fire(e) {\n    if (this._deferredCnt > 0) {\n      if (this._deferredEvent) {\n        this._deferredEvent = this._deferredEvent.merge(e);\n      } else {\n        this._deferredEvent = e;\n      }\n      return;\n    }\n    this._fastEmitter.fire(e);\n    this._slowEmitter.fire(e);\n  }\n}\n/**\n * @internal\n */\nexport class AttachedViews {\n  constructor() {\n    this._onDidChangeVisibleRanges = new Emitter();\n    this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n    this._views = new Set();\n  }\n  attachView() {\n    const view = new AttachedViewImpl(state => {\n      this._onDidChangeVisibleRanges.fire({\n        view,\n        state\n      });\n    });\n    this._views.add(view);\n    return view;\n  }\n  detachView(view) {\n    this._views.delete(view);\n    this._onDidChangeVisibleRanges.fire({\n      view,\n      state: undefined\n    });\n  }\n}\nclass AttachedViewImpl {\n  constructor(handleStateChange) {\n    this.handleStateChange = handleStateChange;\n  }\n  setVisibleLines(visibleLines, stabilized) {\n    const visibleLineRanges = visibleLines.map(line => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n    this.handleStateChange({\n      visibleLineRanges,\n      stabilized\n    });\n  }\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","ArrayQueue","pushMany","Color","BugIndicatingError","illegalArgument","onUnexpectedError","Emitter","Disposable","MutableDisposable","combinedDisposable","strings","URI","countEOL","normalizeIndentation","LineRange","Position","Range","Selection","EDITOR_MODEL_DEFAULTS","ILanguageService","ILanguageConfigurationService","model","BracketPairsTextModelPart","ColorizedBracketPairsDecorationProvider","EditStack","GuidesTextModelPart","guessIndentation","IntervalNode","IntervalTree","recomputeMaxEnd","PieceTreeTextBuffer","PieceTreeTextBufferBuilder","SearchParams","TextModelSearch","TokenizationTextModelPart","InternalModelContentChangeEvent","LineInjectedText","ModelInjectedTextChangedEvent","ModelRawContentChangedEvent","ModelRawEOLChanged","ModelRawFlush","ModelRawLineChanged","ModelRawLinesDeleted","ModelRawLinesInserted","IUndoRedoService","createTextBufferFactory","text","builder","acceptChunk","finish","createTextBufferFactoryFromSnapshot","snapshot","chunk","read","createTextBuffer","value","defaultEOL","factory","isITextSnapshot","create","MODEL_ID","LIMIT_FIND_COUNT","LONG_LINE_BOUNDARY","TextModelSnapshot","constructor","source","_source","_eos","result","resultCnt","resultLength","tmp","join","invalidFunc","Error","TextModel","resolveOptions","textBuffer","options","detectIndentation","guessedIndentation","tabSize","insertSpaces","TextModelResolvedOptions","indentSize","trimAutoWhitespace","bracketPairColorizationOptions","onDidChangeLanguage","_tokenizationTextModelPart","onDidChangeLanguageConfiguration","onDidChangeTokens","onDidChangeContent","listener","_eventEmitter","slowEvent","e","contentChangedEvent","onDidChangeContentOrInjectedText","fastEvent","_onDidChangeInjectedText","event","_isDisposing","__isDisposing","tokenization","bracketPairs","_bracketPairs","guides","_guidesTextModelPart","languageIdOrSelection","creationOptions","associatedResource","_undoRedoService","_languageService","_languageConfigurationService","_onWillDispose","_register","onWillDispose","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","DidChangeContentEmitter","_languageSelectionListener","_deltaDecorationCallCnt","_attachedViews","AttachedViews","id","isForSimpleWidget","_associatedResource","parse","_attachedEditorCount","disposable","_buffer","_bufferDisposable","_options","languageId","onDidChange","_setLanguage","_decorationProvider","bufferLineCount","getLineCount","bufferTextLength","getValueLengthInRange","getLineLength","largeFileOptimizations","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForSyncing","_MODEL_SYNC_LIMIT","_versionId","_alternativeVersionId","_initialUndoRedoSnapshot","_isDisposed","_instanceId","singleLetterHash","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","beginDeferredEmit","fire","endDeferredEmit","requestRichLanguageFeatures","dispose","emptyDisposedTextBuffer","None","_assertNotDisposed","_emitContentChangedEvent","rawChange","change","handleDidChangeContent","setValue","undefined","_setValueFromTextBuffer","_createContentChanged2","range","rangeOffset","rangeLength","isUndoing","isRedoing","isFlush","isEolChange","changes","eol","getEOL","versionId","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","endLineNumber","endColumn","getLineMaxColumn","_increaseVersionId","clear","getValue","setEOL","newEOL","_onBeforeEOLChange","_onAfterEOLChange","ensureAllNodesHaveRanges","allDecorations","collectNodesPostOrder","len","node","delta","cachedAbsoluteStart","start","startOffset","getOffsetAt","startLineNumber","startColumn","endOffset","cachedAbsoluteEnd","cachedVersionId","end","onBeforeAttached","handleDidChangeAttached","attachView","onBeforeDetached","view","detachView","isAttachedToEditor","getAttachedEditorCount","isTooLargeForSyncing","isTooLargeForTokenization","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineCount","lineNumber","lineLength","uri","getOptions","getFormattingOptions","updateOptions","_newOpts","originalIndentSize","bracketColorizationOptions","newOpts","equals","createChangeEvent","handleDidChangeOptions","defaultInsertSpaces","defaultTabSize","str","mightContainRTL","mightContainUnusualLineTerminators","removeUnusualLineTerminators","selections","matches","findMatches","UNUSUAL_LINE_TERMINATORS","resetMightContainUnusualLineTerminators","pushEditOperations","map","m","mightContainNonBasicASCII","getAlternativeVersionId","getInitialUndoRedoSnapshot","rawPosition","position","_validatePosition","column","getPositionAt","rawOffset","offset","Math","min","getLength","max","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","preserveBOM","fullModelRange","fullModelValue","getValueInRange","getBOM","createSnapshot","getValueLength","rawRange","validateRange","getCharacterCountInRange","getLineContent","getLinesContent","getEndOfLineSequence","getLineMinColumn","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","_validateRangeRelaxedNoAllocations","linesCount","initialStartLineNumber","initialStartColumn","floor","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","_isValidPosition","validationType","charCodeBefore","getLineCharCode","isHighSurrogate","_lineNumber","_column","validatePosition","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","_range","modifyPosition","candidate","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","searchString","rawSearchScope","isRegex","matchCase","wordSeparators","searchRanges","Array","isArray","every","searchScope","isIRange","sort","d1","d2","uniqueSearchRanges","push","reduce","prev","curr","areIntersecting","plusRange","matchMapper","indexOf","searchParams","parseSearchRequest","arr","concat","findNextMatch","rawSearchStart","searchStart","ret","findPreviousMatch","pushStackElement","popStackElement","pushEOL","currentEOL","_validateEditOperation","rawOperation","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","_validateEditOperations","rawOperations","beforeCursorState","editOperations","cursorStateComputer","group","_pushEditOperations","incomingEdits","op","editsAreNearCursors","sel","foundEditNearSel","j","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","isEmpty","charAt","trimRange","pushEditOperation","_applyUndo","resultingAlternativeVersionId","resultingSelection","edits","rangeStart","newPosition","rangeEnd","newEnd","oldText","_applyUndoRedoEdits","_applyRedo","oldPosition","oldEnd","newText","applyEdits","computeUndoEdits","operations","_doApplyEdits","oldLineCount","newLineCount","contentChanges","trimAutoWhitespaceLineNumbers","acceptReplace","rawContentChanges","eolCount","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","fromDecorations","injectedTextInEditedRangeQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","spliceStartLineNumber","spliceLineNumber","cnt","fromLineNumber","injectedTexts","newLines","takeWhile","reverseEdits","undo","canUndo","redo","canRedo","size","affectedLines","from","lineChangeEvents","_getInjectedTextInLine","changeDecorations","callback","ownerId","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","newRange","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","console","warn","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","delete","reset","setOptions","insert","removeAllDecorationsWithOwnerId","nodes","collectNodesFromOwner","getDecorationOptions","decorationId","getNodeRange","getLineDecorations","filterOutValidation","getLinesDecorations","_startLineNumber","_endLineNumber","onlyMarginDecorations","decorations","_getDecorationsInRange","getDecorationsInRange","onlyMinimapDecorations","validatedRange","getOverviewRulerDecorations","getAll","getInjectedTextDecorations","getAllInjectedText","filter","t","getAllDecorations","getAllMarginDecorations","filterRange","filterOwnerId","getAllInInterval","getRangeAt","after","oldRange","recordLineAffectedByInjectedText","before","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","color","nodeIsInOverviewRuler","nodeRange","oldDecorationsIds","suppressEvents","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","getLanguageId","setLanguage","setLanguageId","getLanguageIdAtPosition","getWordAtPosition","getWordUntilPosition","normalizePosition","affinity","getLineIndentColumn","indentOfLine","DEFAULT_CREATION_OPTIONS","line","indent","isNodeInOverviewRuler","isNodeInjectedText","_decorationsTree0","_decorationsTree1","_injectedTextDecorationsTree","host","_ensureNodesHaveRanges","_intervalSearch","r0","intervalSearch","r1","r2","showIfCollapsed","search","overviewRulerOnly","_search","_resolveNode","resolveNode","textLength","cleanClassName","className","replace","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","OverviewRulerLane","Center","getColor","theme","type","_resolveColor","invalidateCachedColor","toString","ModelDecorationGlyphMarginOptions","_a","GlyphMarginLane","Left","ModelDecorationMinimapOptions","fromHex","ModelDecorationInjectedTextOptions","content","inlineClassName","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","ModelDecorationOptions","register","createDynamic","_b","_c","_d","_e","_f","description","blockClassName","blockDoesNotCollapse","blockIsAfterEnd","blockPadding","stickiness","zIndex","shouldFillLineOnLineBreak","hoverMessage","glyphMarginHoverMessage","isWholeLine","collapseOnReplaceEdit","minimap","glyphMargin","glyphMarginClassName","linesDecorationsClassName","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","EMPTY","handleBeforeFire","_actual","_affectedInjectedTextLines","_deferredCnt","_shouldFireDeferred","_affectsMinimap","_affectsOverviewRuler","_affectsGlyphMargin","doFire","Set","add","tryFire","affectsMinimap","affectsOverviewRuler","affectsGlyphMargin","_fastEmitter","_slowEmitter","_deferredEvent","rawContentChangedEvent","merge","_onDidChangeVisibleRanges","onDidChangeVisibleRanges","_views","AttachedViewImpl","state","handleStateChange","setVisibleLines","visibleLines","stabilized","visibleLineRanges"],"sources":["/Users/aaron/Desktop/SDE/online_judgement/yuoj-frontend-master/node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize',\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = new TokenizationTextModelPart(this._languageService, this._languageConfigurationService, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n            // Delete + Insert due to an overview ruler status change\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB,  // used in tests\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.DEFAULT_CREATION_OPTIONS = {\n    isForSimpleWidget: false,\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n    detectIndentation: false,\n    defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n    bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n};\nTextModel = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService)\n], TextModel);\nexport { TextModel };\nfunction indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        var _a;\n        this.position = (_a = options === null || options === void 0 ? void 0 : options.position) !== null && _a !== void 0 ? _a : model.GlyphMarginLane.Left;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f;\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = (_a = options.blockDoesNotCollapse) !== null && _a !== void 0 ? _a : null;\n        this.blockIsAfterEnd = (_b = options.blockIsAfterEnd) !== null && _b !== void 0 ? _b : null;\n        this.blockPadding = (_c = options.blockPadding) !== null && _c !== void 0 ? _c : null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = (_d = options.shouldFillLineOnLineBreak) !== null && _d !== void 0 ? _d : null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = (_e = options.hideInCommentTokens) !== null && _e !== void 0 ? _e : false;\n        this.hideInStringTokens = (_f = options.hideInStringTokens) !== null && _f !== void 0 ? _f : false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        var _a;\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        if (!this._affectsMinimap) {\n            this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n        }\n        if (!this._affectsOverviewRuler) {\n            this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n        }\n        if (!this._affectsGlyphMargin) {\n            this._affectsGlyphMargin = options.glyphMarginClassName ? true : false;\n        }\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n/**\n * @internal\n */\nexport class AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n    }\n}\nclass AttachedViewImpl {\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        this.handleStateChange({ visibleLineRanges, stabilized });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}