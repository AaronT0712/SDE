{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { RangeMapping, LineRangeMapping, LinesDiff } from './linesDiffComputer.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class SmartLinesDiffComputer {\n  computeDiff(originalLines, modifiedLines, options) {\n    var _a;\n    const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n      maxComputationTime: options.maxComputationTimeMs,\n      shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n      shouldComputeCharChanges: true,\n      shouldMakePrettyDiff: true,\n      shouldPostProcessCharChanges: true\n    });\n    const result = diffComputer.computeDiff();\n    const changes = [];\n    let lastChange = null;\n    for (const c of result.changes) {\n      let originalRange;\n      if (c.originalEndLineNumber === 0) {\n        // Insertion\n        originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n      } else {\n        originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n      }\n      let modifiedRange;\n      if (c.modifiedEndLineNumber === 0) {\n        // Deletion\n        modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n      } else {\n        modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n      }\n      let change = new LineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n      if (lastChange) {\n        if (lastChange.modifiedRange.endLineNumberExclusive === change.modifiedRange.startLineNumber || lastChange.originalRange.endLineNumberExclusive === change.originalRange.startLineNumber) {\n          // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n          change = new LineRangeMapping(lastChange.originalRange.join(change.originalRange), lastChange.modifiedRange.join(change.modifiedRange), lastChange.innerChanges && change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : undefined);\n          changes.pop();\n        }\n      }\n      changes.push(change);\n      lastChange = change;\n    }\n    assertFn(() => {\n      return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n      // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n      m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber && m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n    });\n    return new LinesDiff(changes, [], result.quitEarly);\n  }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n  const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n  return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n  constructor(lines) {\n    const startColumns = [];\n    const endColumns = [];\n    for (let i = 0, length = lines.length; i < length; i++) {\n      startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n      endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n    }\n    this.lines = lines;\n    this._startColumns = startColumns;\n    this._endColumns = endColumns;\n  }\n  getElements() {\n    const elements = [];\n    for (let i = 0, len = this.lines.length; i < len; i++) {\n      elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n    }\n    return elements;\n  }\n  getStrictElement(index) {\n    return this.lines[index];\n  }\n  getStartLineNumber(i) {\n    return i + 1;\n  }\n  getEndLineNumber(i) {\n    return i + 1;\n  }\n  createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n    const charCodes = [];\n    const lineNumbers = [];\n    const columns = [];\n    let len = 0;\n    for (let index = startIndex; index <= endIndex; index++) {\n      const lineContent = this.lines[index];\n      const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;\n      const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;\n      for (let col = startColumn; col < endColumn; col++) {\n        charCodes[len] = lineContent.charCodeAt(col - 1);\n        lineNumbers[len] = index + 1;\n        columns[len] = col;\n        len++;\n      }\n      if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n        // Add \\n if trim whitespace is not ignored\n        charCodes[len] = 10 /* CharCode.LineFeed */;\n        lineNumbers[len] = index + 1;\n        columns[len] = lineContent.length + 1;\n        len++;\n      }\n    }\n    return new CharSequence(charCodes, lineNumbers, columns);\n  }\n}\nclass CharSequence {\n  constructor(charCodes, lineNumbers, columns) {\n    this._charCodes = charCodes;\n    this._lineNumbers = lineNumbers;\n    this._columns = columns;\n  }\n  toString() {\n    return '[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']';\n  }\n  _assertIndex(index, arr) {\n    if (index < 0 || index >= arr.length) {\n      throw new Error(`Illegal index`);\n    }\n  }\n  getElements() {\n    return this._charCodes;\n  }\n  getStartLineNumber(i) {\n    if (i > 0 && i === this._lineNumbers.length) {\n      // the start line number of the element after the last element\n      // is the end line number of the last element\n      return this.getEndLineNumber(i - 1);\n    }\n    this._assertIndex(i, this._lineNumbers);\n    return this._lineNumbers[i];\n  }\n  getEndLineNumber(i) {\n    if (i === -1) {\n      // the end line number of the element before the first element\n      // is the start line number of the first element\n      return this.getStartLineNumber(i + 1);\n    }\n    this._assertIndex(i, this._lineNumbers);\n    if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n      return this._lineNumbers[i] + 1;\n    }\n    return this._lineNumbers[i];\n  }\n  getStartColumn(i) {\n    if (i > 0 && i === this._columns.length) {\n      // the start column of the element after the last element\n      // is the end column of the last element\n      return this.getEndColumn(i - 1);\n    }\n    this._assertIndex(i, this._columns);\n    return this._columns[i];\n  }\n  getEndColumn(i) {\n    if (i === -1) {\n      // the end column of the element before the first element\n      // is the start column of the first element\n      return this.getStartColumn(i + 1);\n    }\n    this._assertIndex(i, this._columns);\n    if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n      return 1;\n    }\n    return this._columns[i] + 1;\n  }\n}\nclass CharChange {\n  constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalStartColumn = originalStartColumn;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.originalEndColumn = originalEndColumn;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedStartColumn = modifiedStartColumn;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.modifiedEndColumn = modifiedEndColumn;\n  }\n  static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n    const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n    const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n    const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n    const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n    const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n    const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n    const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n  }\n}\nfunction postProcessCharChanges(rawChanges) {\n  if (rawChanges.length <= 1) {\n    return rawChanges;\n  }\n  const result = [rawChanges[0]];\n  let prevChange = result[0];\n  for (let i = 1, len = rawChanges.length; i < len; i++) {\n    const currChange = rawChanges[i];\n    const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n    const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n    // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n    const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n    if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n      // Merge the current change into the previous one\n      prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;\n      prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;\n    } else {\n      // Add the current change\n      result.push(currChange);\n      prevChange = currChange;\n    }\n  }\n  return result;\n}\nclass LineChange {\n  constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.charChanges = charChanges;\n  }\n  static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n    let originalStartLineNumber;\n    let originalEndLineNumber;\n    let modifiedStartLineNumber;\n    let modifiedEndLineNumber;\n    let charChanges = undefined;\n    if (diffChange.originalLength === 0) {\n      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n      originalEndLineNumber = 0;\n    } else {\n      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n      originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n    }\n    if (diffChange.modifiedLength === 0) {\n      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n      modifiedEndLineNumber = 0;\n    } else {\n      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n      modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    }\n    if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n      // Compute character changes for diff chunks of at most 20 lines...\n      const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n      const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n      if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n        let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n        if (shouldPostProcessCharChanges) {\n          rawChanges = postProcessCharChanges(rawChanges);\n        }\n        charChanges = [];\n        for (let i = 0, length = rawChanges.length; i < length; i++) {\n          charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n        }\n      }\n    }\n    return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n  }\n}\nexport class DiffComputer {\n  constructor(originalLines, modifiedLines, opts) {\n    this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n    this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n    this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n    this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n    this.originalLines = originalLines;\n    this.modifiedLines = modifiedLines;\n    this.original = new LineSequence(originalLines);\n    this.modified = new LineSequence(modifiedLines);\n    this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n    this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n  }\n\n  computeDiff() {\n    if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n      // empty original => fast path\n      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n        return {\n          quitEarly: false,\n          changes: []\n        };\n      }\n      return {\n        quitEarly: false,\n        changes: [{\n          originalStartLineNumber: 1,\n          originalEndLineNumber: 1,\n          modifiedStartLineNumber: 1,\n          modifiedEndLineNumber: this.modified.lines.length,\n          charChanges: undefined\n        }]\n      };\n    }\n    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n      // empty modified => fast path\n      return {\n        quitEarly: false,\n        changes: [{\n          originalStartLineNumber: 1,\n          originalEndLineNumber: this.original.lines.length,\n          modifiedStartLineNumber: 1,\n          modifiedEndLineNumber: 1,\n          charChanges: undefined\n        }]\n      };\n    }\n    const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n    const rawChanges = diffResult.changes;\n    const quitEarly = diffResult.quitEarly;\n    // The diff is always computed with ignoring trim whitespace\n    // This ensures we get the prettiest diff\n    if (this.shouldIgnoreTrimWhitespace) {\n      const lineChanges = [];\n      for (let i = 0, length = rawChanges.length; i < length; i++) {\n        lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n      }\n      return {\n        quitEarly: quitEarly,\n        changes: lineChanges\n      };\n    }\n    // Need to post-process and introduce changes where the trim whitespace is different\n    // Note that we are looping starting at -1 to also cover the lines before the first change\n    const result = [];\n    let originalLineIndex = 0;\n    let modifiedLineIndex = 0;\n    for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n      const nextChange = i + 1 < len ? rawChanges[i + 1] : null;\n      const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;\n      const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;\n      while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n        const originalLine = this.originalLines[originalLineIndex];\n        const modifiedLine = this.modifiedLines[modifiedLineIndex];\n        if (originalLine !== modifiedLine) {\n          // These lines differ only in trim whitespace\n          // Check the leading whitespace\n          {\n            let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n            let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n            while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n              const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n              const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n              if (originalChar !== modifiedChar) {\n                break;\n              }\n              originalStartColumn--;\n              modifiedStartColumn--;\n            }\n            if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n            }\n          }\n          // Check the trailing whitespace\n          {\n            let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n            let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n            const originalMaxColumn = originalLine.length + 1;\n            const modifiedMaxColumn = modifiedLine.length + 1;\n            while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n              const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n              const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n              if (originalChar !== modifiedChar) {\n                break;\n              }\n              originalEndColumn++;\n              modifiedEndColumn++;\n            }\n            if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n            }\n          }\n        }\n        originalLineIndex++;\n        modifiedLineIndex++;\n      }\n      if (nextChange) {\n        // Emit the actual change\n        result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n        originalLineIndex += nextChange.originalLength;\n        modifiedLineIndex += nextChange.modifiedLength;\n      }\n    }\n    return {\n      quitEarly: quitEarly,\n      changes: result\n    };\n  }\n  _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n    if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n      // Merged into previous\n      return;\n    }\n    let charChanges = undefined;\n    if (this.shouldComputeCharChanges) {\n      charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n    }\n    result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n  }\n  _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n    const len = result.length;\n    if (len === 0) {\n      return false;\n    }\n    const prevChange = result[len - 1];\n    if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n      // Don't merge with inserts/deletes\n      return false;\n    }\n    if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n      if (this.shouldComputeCharChanges && prevChange.charChanges) {\n        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n      }\n      return true;\n    }\n    if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n      prevChange.originalEndLineNumber = originalLineNumber;\n      prevChange.modifiedEndLineNumber = modifiedLineNumber;\n      if (this.shouldComputeCharChanges && prevChange.charChanges) {\n        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n      }\n      return true;\n    }\n    return false;\n  }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n  const r = strings.firstNonWhitespaceIndex(txt);\n  if (r === -1) {\n    return defaultValue;\n  }\n  return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n  const r = strings.lastNonWhitespaceIndex(txt);\n  if (r === -1) {\n    return defaultValue;\n  }\n  return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n  if (maximumRuntime === 0) {\n    return () => true;\n  }\n  const startTime = Date.now();\n  return () => {\n    return Date.now() - startTime < maximumRuntime;\n  };\n}","map":{"version":3,"names":["LcsDiff","RangeMapping","LineRangeMapping","LinesDiff","strings","Range","assertFn","checkAdjacentItems","LineRange","MINIMUM_MATCHING_CHARACTER_LENGTH","SmartLinesDiffComputer","computeDiff","originalLines","modifiedLines","options","_a","diffComputer","DiffComputer","maxComputationTime","maxComputationTimeMs","shouldIgnoreTrimWhitespace","ignoreTrimWhitespace","shouldComputeCharChanges","shouldMakePrettyDiff","shouldPostProcessCharChanges","result","changes","lastChange","c","originalRange","originalEndLineNumber","originalStartLineNumber","modifiedRange","modifiedEndLineNumber","modifiedStartLineNumber","change","charChanges","map","originalStartColumn","originalEndColumn","modifiedStartColumn","modifiedEndColumn","endLineNumberExclusive","startLineNumber","join","innerChanges","concat","undefined","pop","push","m1","m2","quitEarly","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","diffAlgo","ComputeDiff","LineSequence","constructor","lines","startColumns","endColumns","i","length","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","getElements","elements","len","substring","getStrictElement","index","getStartLineNumber","getEndLineNumber","createCharSequence","startIndex","endIndex","charCodes","lineNumbers","columns","lineContent","startColumn","endColumn","col","charCodeAt","CharSequence","_charCodes","_lineNumbers","_columns","toString","s","idx","String","fromCharCode","_assertIndex","arr","Error","getStartColumn","getEndColumn","CharChange","createFromDiffChange","diffChange","originalCharSequence","modifiedCharSequence","originalStart","originalLength","modifiedStart","modifiedLength","postProcessCharChanges","rawChanges","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","matchingLength","Math","min","LineChange","createFromDiffResult","originalLineSequence","modifiedLineSequence","continueCharDiff","opts","original","modified","continueLineDiff","createContinueProcessingPredicate","diffResult","lineChanges","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","originalChar","modifiedChar","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","r","firstNonWhitespaceIndex","lastNonWhitespaceIndex","maximumRuntime","startTime","Date","now"],"sources":["/Users/aaron/Desktop/SDE/online_judgement/yuoj-frontend-master/node_modules/monaco-editor/esm/vs/editor/common/diff/smartLinesDiffComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { RangeMapping, LineRangeMapping, LinesDiff } from './linesDiffComputer.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class SmartLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        var _a;\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new LineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modifiedRange.endLineNumberExclusive === change.modifiedRange.startLineNumber\n                    || lastChange.originalRange.endLineNumberExclusive === change.originalRange.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new LineRangeMapping(lastChange.originalRange.join(change.originalRange), lastChange.modifiedRange.join(change.modifiedRange), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n                m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n        });\n        return new LinesDiff(changes, [], result.quitEarly);\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}