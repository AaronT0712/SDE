## 1. 分布式锁

1. 这是用来控制，对某种共享资源的使用权限；比如，一个进程中有**多个线程竞争同一个数据**，就使用**锁**；

   - Mutual Exclusion：只有一个竞争者可以持有锁；

   - Security：如果有异常，锁也可以被释放，并重新被持有；

   - Symmetry：加锁 & 解锁，必须是同一个竞争者；

2. 实现的方式

   - 申请上锁，根据**返回结果判断**是否成功 `setnx key value`：set clock 1，返回1，表示上锁成功，否则失效；
     (**如果服务挂了，锁永远无法释放！**)
   - **过期时间 + 原子性执行**：只添加过期时间不行，如果 *刚上锁，就挂了*，**添加过期时间的命令仍然没有执行**，所以使用这个命令 `set key value nx ex second`：一口气实现两个，nx 表示和 setnx 相同；
     (**如果A执行时间 突然变长，锁到期了，B获取了锁，准备执行；A突然恢复过来，并执行完了业务，就会 释放B的锁！**)
   - **Owner锁**：给锁**加个签名**，只能 *解锁自己的*；解锁前，**获取一次锁的消息**，以判断是否是自己的锁；`set lock 牛牛 nx ex 3`，牛牛就是签名；
     (但是，**获取，判断，解锁** 三个命令式分开的，**不是原子性！**极有可能出问题)；
   - **Lua**：一种脚本语言，将整个流程打包 **原子化**！

   <img src="/Users/aaron/Desktop/SDE/训练营/Redis/assets/image-20240725220248391.png" alt="image-20240725220248391" style="zoom:50%;" />

3. 主从容灾 & 哨兵模式 & 多机部署 (了解即可！)

   - Master-Slave：Redis有 **Slave**节点，如果 Master挂了，则 **人工切换节点**，费劲；
   - Sentinel：可以自动灵活切换，但是同步会有延迟 (latency)；
   - Multi-Tier Deployment：**RedLock**：即 **多个Redis集群**，每次获取锁的时候，**大半部分都正确返回**，表示正常；



## 2. 消息队列

