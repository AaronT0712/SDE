#### 1. 如何用1G的内存，查找1000亿个数字中，出现最多的数字

1. 对每个数字 **Hash** 后，(**mod 100**)，将其存到 结果对应的**文件**。
   （假设1000处理过后，获得40，我们就将1000，放入40号文件）
2. 全部处理完后，我们应该有 **100个文件**。
   （Hash的特性，我们会获得 *大概均匀的分布*，此时每个文件就只有 10亿个数字）
3. 用 **HashMap 依次**对每个文件进行mapping，看出现次数最大的数字是什么。



#### 2. 如何设计一个 Random Pool

+ 要求C R是O(1)，而且还可以 *随机获取一个Key*

1. 维持 **两个HashMap** (Key -> Index 以及 Index -> Key)，以及 **最新插入的对应的index**。
2. 每次插入，`map1.put(newKey, index)` 以及 `map2.put(index)`，最后 `index++`。
3. 每次查找，`int randomIdx = (int) (Math.random() * index);` 查找 0 ~ index-1。
4. 删除key后，**维持中间没有空隙**：
   + 目标key，对应的index是j
   + 设置，当前index对应的key，**设置为 j**，j也设置为对应的key
   + remove掉目标key
   + index -= 1



#### 3. bloom filter

一句话：一个 **bit map** + **Hash函数** + **指定计算出几个bits**。

- 存储时：Hash后，放到map上，对应的bits 标1；
- 查询时：Hash后，是否 **全部对应的bits是1**，不是则不存在；
- 这个方法是 会有**错误**的。
  - Map的长度越长，错误越少，但是内存消耗越大；
  - bits数量越长，错误率**先下降，后上升**；(开始特征更加散，后来特征太多，容易全部都是1)